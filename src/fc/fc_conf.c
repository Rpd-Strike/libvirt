/*
 * fc_conf.c: Firecracker configuration management
 *
 * Copyright (C) 2021 Amazon.com, Inc. or its affiliates.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library.  If not, see
 * <http://www.gnu.org/licenses/>.
 */

#include <config.h>

#include "configmake.h"

#include "virutil.h"
#include "virlog.h"

#include "fc_conf.h"
#include "fc_domain.h"

#define VIR_FROM_THIS VIR_FROM_FC

VIR_LOG_INIT("fc.fc_conf");

virDomainXMLOption *
fcDomainXMLConfInit(void)
{
    // The below field is used as the 'opaque' parameter
    // for the domainPostParseCallback function
    // virFCDriverDomainDefParserConfig.priv = driver;

    return virDomainXMLOptionNew(&virFCDriverDomainDefParserConfig,
                                 &virFCDriverPrivateDataCallbacks,
                                 NULL, NULL, NULL);
}

// The two folders represents where the vm specific folders will be stored
// In the folder of a vm there will be files like the std_err, std_output of the firecracker process,
//   the firecracker socket
virFCDriverConfig *
virFCDriverConfigNew(bool privileged)
{
    virFCDriverConfig *cfg = g_new0(virFCDriverConfig, 1);

    if (privileged) {
        cfg->stateDir = g_strdup_printf("%s/libvirt/fc", RUNSTATEDIR);
    } else {
        g_autofree char *cacheDir = NULL;

        cacheDir = virGetUserRuntimeDirectory();

        cfg->stateDir = g_strdup_printf("%s/fc/run", cacheDir);
    }

    return cfg;
}

void
virFCDriverConfigFree(virFCDriverConfig *config)
{
    if (!config)
        return;

    g_free(config->stateDir);
    g_free(config);
}

// We test the version of firecracker so we do not use potential breaking changes
// generated by bad different major versions or
// by having a too old version of firecracker
int
fcExtractVersion(virFCDriver *driver)
{
    unsigned long version = 0;
    char *tmp = NULL;
    g_autofree char *output = NULL;
    g_autofree char *fc_cmd = g_find_program_in_path(FC_CMD);
    g_autoptr(virCommand) cmd = NULL;

    if (!fc_cmd) {
        return -2;
    }

    cmd = virCommandNewArgList(fc_cmd, "--version", NULL);
    virCommandSetOutputBuffer(cmd, &output);

    if (virCommandRun(cmd, NULL) < 0) {
        return -1;
    }

    tmp = output;

    /* expected format: Firecracker v<major>.<minor>.<micro>
       and on following lines other details
    */
    if ((tmp = STRSKIP(tmp, "Firecracker v")) == NULL) {
        virReportError(VIR_ERR_INTERNAL_ERROR, "%s",
                       _("Unexpected output of Firecracker binary"));
        return -1;
    }

    if (virParseVersionString(tmp, &version, true) < 0) {
        virReportError(VIR_ERR_INTERNAL_ERROR,
                       _("Unable to parse Firecracker version: %s"), tmp);
        return -1;
    }

    if (version < MIN_FIRECRACKER_VERSION) {
        virReportError(VIR_ERR_INTERNAL_ERROR,
                       _("Firecracker version is too old (minimum supported version %d.%d.%d)"),
                       MIN_FIRECRACKER_VERSION / (1000 * 1000), MIN_FIRECRACKER_VERSION / 1000 % 1000, MIN_FIRECRACKER_VERSION % 1000);
        return -1;
    }

    // We support only a specific major version of Firecracker as in between majors there are breaking changes
    if (version / (1000 * 1000) != MIN_FIRECRACKER_VERSION / (1000 * 1000)) {
        virReportError(VIR_ERR_INTERNAL_ERROR,
                       _("Firecracker major version not supported (Supported version is %d.*.*)"),
                       MIN_FIRECRACKER_VERSION / (1000 * 1000));
        return -1;
    }

    driver->version = version;
    return 0;
}
